{"ast":null,"code":"import _slicedToArray from \"/home/blacksmurf/Desktop/Marion/Explorer_Export/Explorer_Export/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/home/blacksmurf/Desktop/Marion/Explorer_Export/Explorer_Export/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/blacksmurf/Desktop/Marion/Explorer_Export/Explorer_Export/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/blacksmurf/Desktop/Marion/Explorer_Export/Explorer_Export/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/blacksmurf/Desktop/Marion/Explorer_Export/Explorer_Export/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/blacksmurf/Desktop/Marion/Explorer_Export/Explorer_Export/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/blacksmurf/Desktop/Marion/Explorer_Export/Explorer_Export/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/home/blacksmurf/Desktop/Marion/Explorer_Export/Explorer_Export/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nvar _jsxFileName = \"/home/blacksmurf/Desktop/Marion/Explorer_Export/Explorer_Export/src/Projection.js\";\nimport React, { Component } from 'react';\nimport * as THREE from 'three';\nimport * as _ from 'lodash';\nimport * as d3 from 'd3';\nimport * as TWEEN from '@tweenjs/tween.js';\nvar tile_string = 'tile_image_';\n\nvar Projection = /*#__PURE__*/function (_Component) {\n  _inherits(Projection, _Component);\n\n  function Projection(props) {\n    var _this;\n\n    _classCallCheck(this, Projection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Projection).call(this, props));\n\n    _this.handleResize = function (width, height) {\n      _this.camera.aspect = width / height;\n\n      _this.camera.updateProjectionMatrix();\n\n      _this.renderer.setSize(width, height);\n\n      var current_scale = _this.getScaleFromZ(_this.camera.position.z);\n\n      var d3_x = -(_this.camera.position.x * current_scale) + _this.props.width / 2;\n      var d3_y = _this.camera.position.y * current_scale + _this.props.height / 2;\n      var resize_transform = d3.zoomIdentity.translate(d3_x, d3_y).scale(current_scale);\n      var view = d3.select(_this.mount);\n\n      _this.d3_zoom.transform(view, resize_transform);\n    };\n\n    _this.state = {};\n    _this.init = _this.init.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.addPoints = _this.addPoints.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleResize = _this.handleResize.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.setUpCamera = _this.setUpCamera.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.animate = _this.animate.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.getScaleFromZ = _this.getScaleFromZ.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.getZFromScale = _this.getZFromScale.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.changeEmbeddings = _this.changeEmbeddings.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.changeLabels = _this.changeLabels.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.tile_locations = _toConsumableArray(Array(_this.props.sprite_number)).map(function (n, i) {\n      return \"\".concat(process.env.PUBLIC_URL, \"/\").concat(tile_string).concat(i, \".png\");\n    });\n    _this._images = _this.tile_locations.map(function (src) {\n      var img = document.createElement('img');\n      img.src = src;\n      return img;\n    });\n    _this.scale1 = d3.scaleLinear().domain([20, 3]).range([_this.props.zoom_min, _this.props.zoom_mid]).clamp(true);\n    _this.scale2 = d3.scaleLinear().domain([3, 0]).range([_this.props.zoom_mid, _this.props.zoom_max]);\n    return _this;\n  }\n\n  _createClass(Projection, [{\n    key: \"changeEmbeddings\",\n    value: function changeEmbeddings(prev_choice, new_choice) {\n      var _this2 = this;\n\n      // assumes mnist embeddings has been updated\n      var ranges = [];\n\n      for (var i = 0; i < this.props.sprite_number; i++) {\n        var start = i * this.props.sprite_size;\n        var end = (i + 1) * this.props.sprite_size;\n        if (i === this.props.sprite_number - 1) end = this.props.sprite_number * this.props.sprite_size;\n        ranges.push([start, end]);\n      }\n\n      var embedding_chunks = ranges.map(function (range) {\n        return _this2.props.embedding_stack[new_choice].slice(range[0], range[1]);\n      });\n\n      var _loop = function _loop(c) {\n        var echunk = embedding_chunks[c];\n        var points = _this2.scene.children[0].children[c];\n        var numVertices = echunk.length;\n        var position = points.geometry.attributes.position.array;\n        var target = new Float32Array(numVertices * 3);\n\n        for (var _i = 0, index = 0, l = numVertices; _i < l; _i++, index += 3) {\n          var x = echunk[_i][0];\n          var y = echunk[_i][1];\n          var z = 0;\n          target[index] = x;\n          target[index + 1] = y;\n          target[index + 2] = z;\n        }\n\n        var tween = new TWEEN.Tween(position).to(target, 1000).easing(TWEEN.Easing.Linear.None);\n        tween.onUpdate(function () {\n          points.geometry.attributes.position = new THREE.BufferAttribute(position, 3);\n          points.geometry.attributes.position.needsUpdate = true; // required after the first render\n\n          points.geometry.computeBoundingSphere();\n        });\n        tween.start();\n      };\n\n      for (var c = 0; c < this.props.sprite_number; c++) {\n        _loop(c);\n      }\n    }\n  }, {\n    key: \"changeLabels\",\n    value: function changeLabels(new_choice) {\n      var _this3 = this;\n\n      // assumes mnist embeddings has been updated\n      var color_array = this.props.color_array_stack[new_choice];\n      var ranges = [];\n\n      for (var i = 0; i < this.props.sprite_number; i++) {\n        var start = i * this.props.sprite_size;\n        var end = (i + 1) * this.props.sprite_size;\n        if (i === this.props.sprite_number - 1) end = this.props.sprite_number * this.props.sprite_size;\n        ranges.push([start, end]);\n      }\n\n      var label_chunks = ranges.map(function (range) {\n        return _this3.props.label_stack[new_choice].slice(range[0], range[1]);\n      });\n\n      var _loop2 = function _loop2(c) {\n        var points = _this3.scene.children[0].children[c];\n        var lchunk = label_chunks[c];\n        var numVertices = lchunk.length;\n        var color_o = points.geometry.attributes.color.array;\n        var colors = new Float32Array(numVertices * 3);\n\n        for (var _i2 = 0, index = 0, l = numVertices; _i2 < l; _i2++, index += 3) {\n          var color = color_array[lchunk[_i2]];\n          colors[index] = color[0] / 255;\n          colors[index + 1] = color[1] / 255;\n          colors[index + 2] = color[2] / 255;\n        }\n\n        var tween = new TWEEN.Tween(color_o).to(colors, 1000).easing(TWEEN.Easing.Linear.None);\n        tween.onUpdate(function () {\n          points.geometry.attributes.color = new THREE.BufferAttribute(color_o, 3);\n          points.geometry.attributes.color.needsUpdate = true; // required after the first render\n\n          points.geometry.computeBoundingSphere();\n        });\n        tween.start();\n      };\n\n      for (var c = 0; c < this.props.sprite_number; c++) {\n        _loop2(c);\n      }\n    }\n  }, {\n    key: \"getZFromScale\",\n    value: function getZFromScale(scale) {\n      var rvFOV = THREE.Math.degToRad(this.camera.fov);\n      var scale_height = this.props.height / scale;\n      var camera_z_position = scale_height / (2 * Math.tan(rvFOV / 2));\n      return camera_z_position;\n    }\n  }, {\n    key: \"getScaleFromZ\",\n    value: function getScaleFromZ(camera_z_position) {\n      var rvFOV = THREE.Math.degToRad(this.camera.fov);\n      var half_fov_height = Math.tan(rvFOV / 2) * camera_z_position;\n      var fov_height = half_fov_height * 2;\n      var scale = this.props.height / fov_height;\n      return scale;\n    }\n  }, {\n    key: \"zoomHandler\",\n    value: function zoomHandler() {\n      var _this4 = this;\n\n      var d3_transform = d3.event.transform;\n      var scale = d3_transform.k;\n      var x = -(d3_transform.x - this.props.width / 2) / scale;\n      var y = (d3_transform.y - this.props.height / 2) / scale;\n      var z = this.getZFromScale(scale);\n      this.camera.position.set(x, y, z); // point size scales at end of zoom\n\n      var zoomScaler = function zoomScaler(input) {\n        if (input >= 3) {\n          return _this4.scale1(input);\n        } else {\n          return _this4.scale2(input);\n        }\n      };\n\n      var new_size = zoomScaler(z);\n      var point_group = this.scene.children[0].children;\n\n      for (var c = 0; c < point_group.length; c++) {\n        point_group[c].material.uniforms.size.value = new_size;\n      }\n    }\n  }, {\n    key: \"setUpCamera\",\n    value: function setUpCamera() {\n      var _this$props = this.props,\n          width = _this$props.width,\n          height = _this$props.height,\n          embeddings = _this$props.embeddings;\n      var aspect = this.camera.aspect;\n      var vFOV = this.camera.fov;\n      var rvFOV = THREE.Math.degToRad(vFOV);\n      var xs = embeddings.map(function (e) {\n        return e[0];\n      });\n\n      var min_x = _.min(xs);\n\n      var max_x = _.max(xs);\n\n      var ys = embeddings.map(function (e) {\n        return e[1];\n      });\n\n      var min_y = _.min(ys);\n\n      var max_y = _.max(ys);\n\n      var data_width = max_x - min_x;\n      var data_height = max_y - min_y;\n      var data_aspect = data_width / data_height;\n\n      var max_x_from_center = _.max([min_x, max_x].map(function (m) {\n        return Math.abs(m);\n      }));\n\n      var max_y_from_center = _.max([min_y, max_y].map(function (m) {\n        return Math.abs(m);\n      }));\n\n      var max_center = Math.max(max_x_from_center, max_y_from_center);\n      var camera_z_start;\n\n      if (data_aspect > aspect) {// console.log(\"width is limiter\");\n        // camera_z_start = max_x_from_center / Math.tan(rvFOV / 2) / aspect\n      } else {// console.log(\"height is limiter\");\n          // camera_z_start = max_y_from_center / Math.tan(rvFOV / 2)\n        }\n\n      camera_z_start = max_center / Math.tan(rvFOV / 2);\n      var far = camera_z_start * 1.25;\n      this.camera.far = far;\n      this.camera.position.z = camera_z_start * 1.1; // set up zoom\n\n      this.d3_zoom = d3.zoom().scaleExtent([this.getScaleFromZ(far - 1), this.getScaleFromZ(0.1)]).on('zoom', this.zoomHandler.bind(this));\n      var view = d3.select(this.mount);\n      this.view = view;\n      view.call(this.d3_zoom);\n      var initial_scale = this.getScaleFromZ(this.camera.position.z);\n      var initial_transform = d3.zoomIdentity.translate(width / 2, height / 2).scale(initial_scale);\n      this.d3_zoom.transform(view, initial_transform);\n    }\n  }, {\n    key: \"addPoints\",\n    value: function addPoints() {\n      var _this$props2 = this.props,\n          embeddings = _this$props2.embeddings,\n          labels = _this$props2.labels,\n          color_array = _this$props2.color_array; // split embeddings and labels into chunks to match sprites\n\n      var ranges = [];\n\n      for (var i = 0; i < this.props.sprite_number; i++) {\n        var start = i * this.props.sprite_size;\n        var end = (i + 1) * this.props.sprite_size;\n        if (i === this.props.sprite_number - 1) end = this.props.sprite_number * this.props.sprite_size;\n        ranges.push([start, end]);\n      }\n\n      var embedding_chunks = ranges.map(function (range) {\n        return embeddings.slice(range[0], range[1]);\n      });\n      var label_chunks = ranges.map(function (range) {\n        return labels.slice(range[0], range[1]);\n      }); // load the textures\n\n      var loader = new THREE.TextureLoader();\n      this.textures = this.tile_locations.map(function (l) {\n        var t = loader.load(l);\n        t.flipY = false;\n        t.magFilter = THREE.NearestFilter; // t.minFilter = THREE.LinearMipMapLinearFilter;\n\n        return t;\n      });\n      var point_group = new THREE.Group();\n\n      for (var c = 0; c < this.props.sprite_number; c++) {\n        var echunk = embedding_chunks[c];\n        var lchunk = label_chunks[c];\n        var vertices = [];\n\n        for (var v = 0; v < echunk.length; v++) {\n          var embedding = echunk[v];\n          var vert = new THREE.Vector3(embedding[0], embedding[1], 0);\n          vertices[v] = vert;\n        }\n\n        var geometry = new THREE.BufferGeometry();\n        var numVertices = vertices.length;\n        var positions = new Float32Array(numVertices * 3);\n        var offsets = new Float32Array(numVertices * 2);\n        var colors = new Float32Array(numVertices * 3);\n        geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n        geometry.addAttribute('offset', new THREE.BufferAttribute(offsets, 2));\n        geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));\n\n        for (var _i3 = 0, index = 0, l = numVertices; _i3 < l; _i3++, index += 3) {\n          var x = echunk[_i3][0];\n          var y = echunk[_i3][1];\n          var z = 0;\n          positions[index] = x;\n          positions[index + 1] = y;\n          positions[index + 2] = z;\n        } // geometry.attributes.position.copyVector3sArray(vertices)\n\n\n        var texture_subsize_x = 1 / this.props.sprite_side_x;\n        var texture_subsize_y = 1 / this.props.sprite_side_y;\n\n        for (var _i4 = 0, _index = 0, _l = numVertices; _i4 < _l; _i4++, _index += 2) {\n          var _x = _i4 % this.props.sprite_side_x * this.props.sprite_image_width / this.props.sprite_actual_size;\n\n          var _y = Math.floor(_i4 / this.props.sprite_side_y) * this.props.sprite_image_height / this.props.sprite_actual_size;\n\n          offsets[_index] = _x;\n          offsets[_index + 1] = _y;\n        }\n\n        for (var _i5 = 0, _index2 = 0, _l2 = numVertices; _i5 < _l2; _i5++, _index2 += 3) {\n          var color = color_array[lchunk[_i5]];\n          colors[_index2] = color[0] / 255;\n          colors[_index2 + 1] = color[1] / 255;\n          colors[_index2 + 2] = color[2] / 255;\n        }\n\n        var point_size = Math.max(this.props.sprite_image_width, this.props.sprite_image_height); // uniforms\n\n        var uniforms = {\n          texture: {\n            value: this.textures[c]\n          },\n          repeat: {\n            value: new THREE.Vector2(texture_subsize_x, texture_subsize_y)\n          },\n          size: {\n            value: point_size\n          },\n          height: {\n            value: this.props.sprite_image_height\n          },\n          width: {\n            value: this.props.sprite_image_width\n          }\n        };\n        var vertex_shader = \"\\n        attribute vec2 offset;\\n        varying vec2 vOffset;\\n        attribute vec3 color;\\n        varying vec3 vColor;\\n        uniform float size;\\n        void main() {\\n          vOffset = offset;\\n          vColor = color;\\n          gl_PointSize = size;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\";\n        var fragment_shader = void 0;\n\n        if (this.props.colored_images == 0) {\n          fragment_shader = \"\\n          uniform sampler2D texture;\\n          uniform vec2 repeat;\\n          uniform float height;\\n          uniform float width;\\n          varying vec2 vOffset;\\n          varying vec3 vColor;\\n          void main() {\\n            if (width>height){\\n              float height_rel = height/width;\\n              float start_rel = (width-height)/(2.0*width);\\n              float end_rel = start_rel+height_rel;\\n              if (gl_PointCoord.y>=start_rel && gl_PointCoord.y<=end_rel) {\\n                float y_new = ((gl_PointCoord.y-start_rel)/height_rel);\\n                vec2 uv = vec2( gl_PointCoord.x, y_new );\\n                vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n                if ( tex.r < 0.05 ) discard;\\n                tex.r = 1.0;\\n                tex.g = 1.0;\\n                tex.b = 1.0;\\n                gl_FragColor = tex * vec4(vColor, 1.0);\\n              } else {\\n                discard;\\n              }\\n            } else if (width<height) {\\n              float width_rel = width/height;\\n              float start_rel = (height-width)/(2.0*height);\\n              float end_rel = start_rel+width_rel;\\n              if (gl_PointCoord.x>=start_rel && gl_PointCoord.x<=end_rel) {\\n                float x_new = ((gl_PointCoord.x-start_rel)/width_rel);\\n                vec2 uv = vec2( x_new,gl_PointCoord.y );\\n                vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n                if ( tex.r < 0.05 ) discard;\\n                tex.r = 1.0;\\n                tex.g = 1.0;\\n                tex.b = 1.0;\\n                gl_FragColor = tex * vec4(vColor, 1.0);\\n              } else {\\n                discard;\\n              }\\n            } else {\\n              vec2 uv = vec2( gl_PointCoord.x, gl_PointCoord.y );\\n              vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n              if ( tex.r < 0.5) discard;\\n              tex.r = 1.0;\\n              tex.g = 1.0;\\n              tex.b = 1.0;\\n              gl_FragColor = tex * vec4(vColor, 1.0); \\n            }\\n          }\";\n        } else if (this.props.colored_images == -1) {\n          fragment_shader = \"\\n          uniform sampler2D texture;\\n          uniform vec2 repeat;\\n          uniform float height;\\n          uniform float width;\\n          varying vec2 vOffset;\\n          varying vec3 vColor;\\n          void main() {\\n            if (width>height){\\n              float height_rel = height/width;\\n              float start_rel = (width-height)/(2.0*width);\\n              float end_rel = start_rel+height_rel;\\n              if (gl_PointCoord.y>=start_rel && gl_PointCoord.y<=end_rel) {\\n                float y_new = ((gl_PointCoord.y-start_rel)/height_rel);\\n                vec2 uv = vec2( gl_PointCoord.x, y_new );\\n                vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n                if ( tex.r < 0.05 ) discard;\\n                tex.r = 1.0;\\n                tex.g = 1.0;\\n                tex.b = 1.0;\\n                gl_FragColor = tex * vec4(vColor, 1.0);\\n              } else {\\n                discard;\\n              }\\n            } else if (width<height) {\\n              float width_rel = width/height;\\n              float start_rel = (height-width)/(2.0*height);\\n              float end_rel = start_rel+width_rel;\\n              if (gl_PointCoord.x>=start_rel && gl_PointCoord.x<=end_rel) {\\n                float x_new = ((gl_PointCoord.x-start_rel)/width_rel);\\n                vec2 uv = vec2( x_new,gl_PointCoord.y );\\n                vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n                if ( tex.r < 0.05 ) discard;\\n                tex.r = 1.0;\\n                tex.g = 1.0;\\n                tex.b = 1.0;\\n                gl_FragColor = tex * vec4(vColor, 1.0);\\n              } else {\\n                discard;\\n              }\\n            } else {\\n              vec2 uv = vec2( gl_PointCoord.x, gl_PointCoord.y );\\n              vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n              if ( tex.b < 0.5 && tex.r==0.0) discard;\\n              if (tex.r>0.0){\\n                tex.r = tex.r;\\n                tex.g = 0.0;\\n                tex.b = 0.0;\\n                gl_FragColor = tex; \\n              }\\n              else{\\n                tex.r = 1.0;\\n                tex.g = 1.0;\\n                tex.b = 1.0;\\n                gl_FragColor = tex * vec4(vColor, 1.0); \\n              }\\n            }\\n          }\";\n        } else {\n          fragment_shader = \"\\n        uniform sampler2D texture;\\n        uniform vec2 repeat;\\n        uniform float height;\\n        uniform float width;\\n        varying vec2 vOffset;\\n        varying vec3 vColor;\\n        void main() {\\n          if (width>height){\\n            float height_rel = height/width;\\n            float start_rel = (width-height)/(2.0*width);\\n            float end_rel = start_rel+height_rel;\\n            if (gl_PointCoord.y>=start_rel && gl_PointCoord.y<=end_rel) {\\n              float y_new = ((gl_PointCoord.y-start_rel)/height_rel);\\n              vec2 uv = vec2( gl_PointCoord.x, y_new );\\n              vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n              gl_FragColor = tex;\\n            } else {\\n              discard;\\n            }\\n          } else if (width<height) {\\n            float width_rel = width/height;\\n            float start_rel = (height-width)/(2.0*height);\\n            float end_rel = start_rel+width_rel;\\n            if (gl_PointCoord.x>=start_rel && gl_PointCoord.x<=end_rel) {\\n              float x_new = ((gl_PointCoord.x-start_rel)/width_rel);\\n              vec2 uv = vec2( x_new, gl_PointCoord.y );\\n              vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n              gl_FragColor = tex;\\n            } else {\\n              discard;\\n            }\\n          } else {\\n            vec2 uv = vec2( gl_PointCoord.x, gl_PointCoord.y );\\n            vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n            gl_FragColor = tex;\\n          }\\n        }\";\n        } // material\n\n\n        var material = new THREE.ShaderMaterial({\n          uniforms: uniforms,\n          vertexShader: vertex_shader,\n          fragmentShader: fragment_shader\n        }); // point cloud\n\n        var point_cloud = new THREE.Points(geometry, material);\n        point_cloud.userData = {\n          sprite_index: c\n        };\n        point_group.add(point_cloud);\n      }\n\n      this.scene.add(point_group);\n    }\n  }, {\n    key: \"addBlankHighlightPoints\",\n    value: function addBlankHighlightPoints() {\n      var hover_container = new THREE.Group();\n      this.scene.add(hover_container);\n      var vert = new THREE.Vector3(0, 0, 0);\n      var vertices = [vert];\n      var geometry = new THREE.BufferGeometry();\n      var numVertices = vertices.length;\n      var positions = new Float32Array(numVertices * 3); // 3 coordinates per point\n\n      var offsets = new Float32Array(numVertices * 2); // 2 coordinates per point\n\n      geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n      geometry.addAttribute('offset', new THREE.BufferAttribute(offsets, 2)); // all the attributes will be filled on hover\n\n      var texture_subsize_x = 1 / this.props.sprite_side_x;\n      var texture_subsize_y = 1 / this.props.sprite_side_y;\n      var point_size = this.props.hoover_size; //Math.max(this.props.sprite_image_width,this.props.sprite_image_height)\n      // uniforms\n\n      var uniforms = {\n        texture: {\n          value: this.textures[0]\n        },\n        repeat: {\n          value: new THREE.Vector2(texture_subsize_x, texture_subsize_y)\n        },\n        size: {\n          value: point_size\n        },\n        height: {\n          value: this.props.sprite_image_height\n        },\n        width: {\n          value: this.props.sprite_image_width\n        }\n      };\n      var vertex_shader = \"\\n        attribute vec2 offset;\\n        varying vec2 vOffset;\\n        uniform float size;\\n        void main() {\\n          vOffset = offset;\\n          gl_PointSize = size;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\";\n      var fragment_shader;\n\n      if (this.props.colored_images == 0) {\n        fragment_shader = \"\\n          uniform sampler2D texture;\\n          uniform vec2 repeat;\\n          uniform float height;\\n          uniform float width;\\n          varying vec2 vOffset;\\n          varying vec3 vColor;\\n          void main() {\\n            if (width>height){\\n              float height_rel = height/width;\\n              float start_rel = (width-height)/(2.0*width);\\n              float end_rel = start_rel+height_rel;\\n              if (gl_PointCoord.y>=start_rel && gl_PointCoord.y<=end_rel) {\\n                float y_new = ((gl_PointCoord.y-start_rel)/height_rel);\\n                vec2 uv = vec2( gl_PointCoord.x, y_new );\\n                vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n                tex.a = tex.r;\\n                tex.r = 1.0;\\n                tex.g = 1.0;\\n                tex.b = 1.0;\\n                gl_FragColor = tex;\\n              } else {\\n                discard;\\n              }\\n            } else if (width<height) {\\n              float width_rel = width/height;\\n              float start_rel = (height-width)/(2.0*height);\\n              float end_rel = start_rel+width_rel;\\n              if (gl_PointCoord.x>=start_rel && gl_PointCoord.x<=end_rel) {\\n                float x_new = ((gl_PointCoord.x-start_rel)/width_rel);\\n                vec2 uv = vec2( x_new,gl_PointCoord.y );\\n                vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n                tex.a = tex.r;\\n                tex.r = 1.0;\\n                tex.g = 1.0;\\n                tex.b = 1.0;\\n                gl_FragColor = tex; \\n              } else {\\n                discard;\\n              }\\n            } else {\\n              vec2 uv = vec2( gl_PointCoord.x, gl_PointCoord.y );\\n              vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n              tex.a = tex.r;\\n              tex.r = 1.0;\\n              tex.g = 1.0;\\n              tex.b = 1.0;\\n              gl_FragColor = tex; \\n            }\\n          }\";\n      } else {\n        fragment_shader = \"\\n        uniform sampler2D texture;\\n        uniform vec2 repeat;\\n        uniform float height;\\n        uniform float width;\\n        varying vec2 vOffset;\\n        varying vec3 vColor;\\n        void main() {\\n          if (width>height){\\n            float height_rel = height/width;\\n            float start_rel = (width-height)/(2.0*width);\\n            float end_rel = start_rel+height_rel;\\n            if (gl_PointCoord.y>=start_rel && gl_PointCoord.y<=end_rel) {\\n              float y_new = ((gl_PointCoord.y-start_rel)/height_rel);\\n              vec2 uv = vec2( gl_PointCoord.x, y_new );\\n              vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n              gl_FragColor = tex;\\n            } else {\\n              discard;\\n            }\\n          } else if (width<height) {\\n            float width_rel = width/height;\\n            float start_rel = (height-width)/(2.0*height);\\n            float end_rel = start_rel+width_rel;\\n            if (gl_PointCoord.x>=start_rel && gl_PointCoord.x<=end_rel) {\\n              float x_new = ((gl_PointCoord.x-start_rel)/width_rel);\\n              vec2 uv = vec2( x_new, gl_PointCoord.y );\\n              vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n              gl_FragColor = tex;\\n            } else {\\n              discard;\\n            }\\n          } else {\\n            vec2 uv = vec2( gl_PointCoord.x, gl_PointCoord.y );\\n            vec4 tex = texture2D( texture, uv * repeat + vOffset );\\n            gl_FragColor = tex;\\n          }\\n        }\";\n      } // material\n\n\n      var material = new THREE.ShaderMaterial({\n        uniforms: uniforms,\n        vertexShader: vertex_shader,\n        fragmentShader: fragment_shader,\n        transparent: true\n      });\n      var point = new THREE.Points(geometry, material);\n      point.frustumCulled = false;\n      this.scene.children[1].visible = false;\n      this.scene.children[1].add(point);\n    }\n  }, {\n    key: \"highlightPoint\",\n    value: function highlightPoint(sprite_index, digit_index, full_index) {\n      var algorithm_choice = this.props.algorithm_choice;\n      var point = this.scene.children[1].children[0];\n      var embedding = this.props.embedding_stack.slice()[algorithm_choice][full_index]; //[full_index]\n\n      var vert = new THREE.Vector3(embedding[0], embedding[1], 0);\n      var vertices = [vert];\n      var offsets = new Float32Array(2); // 2 coordinates per point\n\n      var x = digit_index % this.props.sprite_side_x * this.props.sprite_image_width / this.props.sprite_actual_size;\n      var y = Math.floor(digit_index / this.props.sprite_side_y) * this.props.sprite_image_height / this.props.sprite_actual_size;\n      offsets[0] = x;\n      offsets[1] = y;\n      point.geometry.attributes.position.copyVector3sArray(vertices);\n      point.geometry.attributes.position.needsUpdate = true; // required after the first render\n\n      point.geometry.attributes.offset.array = offsets;\n      point.geometry.attributes.offset.needsUpdate = true; // required after the first render\n      // need to set attributes on geometry and uniforms on material\n\n      point.material.uniforms.texture.value = this.textures[sprite_index];\n    }\n  }, {\n    key: \"removeHighlights\",\n    value: function removeHighlights() {\n      var highlight_container = this.scene.children[1];\n      var highlights = highlight_container.children;\n      highlight_container.remove.apply(highlight_container, _toConsumableArray(highlights));\n    }\n  }, {\n    key: \"checkIntersects\",\n    value: function checkIntersects(mouse_position) {\n      var _this$props3 = this.props,\n          width = _this$props3.width,\n          height = _this$props3.height,\n          sidebar_ctx = _this$props3.sidebar_ctx,\n          sidebar_image_size_width = _this$props3.sidebar_image_size_width,\n          sidebar_image_size_height = _this$props3.sidebar_image_size_height;\n\n      function mouseToThree(_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            mouseX = _ref2[0],\n            mouseY = _ref2[1];\n\n        return new THREE.Vector3(mouseX / width * 2 - 1, -(mouseY / height) * 2 + 1, 1);\n      }\n\n      function sortIntersectsByDistanceToRay(intersects) {\n        return _.sortBy(intersects, 'distanceToRay');\n      }\n\n      var mouse_vector = mouseToThree(mouse_position);\n      this.raycaster.setFromCamera(mouse_vector, this.camera);\n      this.raycaster.params.Points.threshold = 0.5;\n      var intersects = this.raycaster.intersectObjects(this.scene.children[0].children);\n\n      if (intersects[0]) {\n        var sorted_intersects = sortIntersectsByDistanceToRay(intersects);\n        var intersect = sorted_intersects[0];\n        var sprite_index = intersect.object.userData.sprite_index;\n        var digit_index = intersect.index;\n        var full_index = sprite_index * this.props.sprite_size + digit_index;\n        this.props.setHoverIndex(full_index);\n        this.highlightPoint(sprite_index, digit_index, full_index);\n        this.scene.children[1].visible = true;\n        sidebar_ctx.fillRect(0, 0, sidebar_image_size_width, sidebar_image_size_height);\n        sidebar_ctx.drawImage(this._images[sprite_index], // source rectangle\n        digit_index % this.props.sprite_side_x * this.props.sprite_image_width, Math.floor(digit_index / this.props.sprite_side_y) * this.props.sprite_image_height, this.props.sprite_image_width, this.props.sprite_image_height, // destination rectangle\n        0, 0, sidebar_image_size_width, sidebar_image_size_height);\n      } else {\n        this.props.setHoverIndex(null);\n        this.scene.children[1].visible = false;\n        sidebar_ctx.fillRect(0, 0, sidebar_image_size_width, sidebar_image_size_height);\n      }\n    }\n  }, {\n    key: \"handleMouse\",\n    value: function handleMouse() {\n      var _this5 = this;\n\n      var view = d3.select(this.renderer.domElement);\n      this.raycaster = new THREE.Raycaster();\n      view.on('mousemove', function () {\n        var _d3$mouse = d3.mouse(view.node()),\n            _d3$mouse2 = _slicedToArray(_d3$mouse, 2),\n            mouseX = _d3$mouse2[0],\n            mouseY = _d3$mouse2[1];\n\n        var mouse_position = [mouseX, mouseY];\n\n        _this5.checkIntersects(mouse_position);\n      });\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      var _this$props4 = this.props,\n          width = _this$props4.width,\n          height = _this$props4.height,\n          sidebar_ctx = _this$props4.sidebar_ctx;\n      this.scene = new THREE.Scene();\n      var vFOV = 75;\n      var aspect = width / height;\n      var near = 0.01;\n      var far = 1000;\n      this.camera = new THREE.PerspectiveCamera(vFOV, aspect, near, far);\n      this.renderer = new THREE.WebGLRenderer();\n      this.renderer.setClearColor(0x111111, 1);\n      this.renderer.setSize(width, height);\n      this.mount.appendChild(this.renderer.domElement);\n      this.addPoints();\n      this.addBlankHighlightPoints();\n      this.setUpCamera();\n      this.animate();\n      this.handleMouse();\n    }\n  }, {\n    key: \"animate\",\n    value: function animate() {\n      requestAnimationFrame(this.animate);\n      TWEEN.update();\n      this.renderer.render(this.scene, this.camera);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.init();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this$props5 = this.props,\n          width = _this$props5.width,\n          height = _this$props5.height;\n\n      if (width !== prevProps.width || height !== prevProps.height) {\n        this.handleResize(width, height);\n      }\n\n      if (prevProps.algorithm_choice !== this.props.algorithm_choice) {\n        this.changeEmbeddings(prevProps.algorithm_choice, this.props.algorithm_choice);\n      }\n\n      if (prevProps.label_choice !== this.props.label_choice) {\n        this.changeLabels(this.props.label_choice);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.mount.removeChild(this.renderer.domElement);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this6 = this;\n\n      var _this$props6 = this.props,\n          width = _this$props6.width,\n          height = _this$props6.height;\n      return /*#__PURE__*/React.createElement(\"div\", {\n        style: {\n          width: width,\n          height: height,\n          overflow: 'hidden'\n        },\n        ref: function ref(mount) {\n          _this6.mount = mount;\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 823,\n          columnNumber: 7\n        }\n      });\n    }\n  }]);\n\n  return Projection;\n}(Component);\n\nexport default Projection;","map":{"version":3,"sources":["/home/blacksmurf/Desktop/Marion/Explorer_Export/Explorer_Export/src/Projection.js"],"names":["React","Component","THREE","_","d3","TWEEN","tile_string","Projection","props","handleResize","width","height","camera","aspect","updateProjectionMatrix","renderer","setSize","current_scale","getScaleFromZ","position","z","d3_x","x","d3_y","y","resize_transform","zoomIdentity","translate","scale","view","select","mount","d3_zoom","transform","state","init","bind","addPoints","setUpCamera","animate","getZFromScale","changeEmbeddings","changeLabels","tile_locations","Array","sprite_number","map","n","i","process","env","PUBLIC_URL","_images","src","img","document","createElement","scale1","scaleLinear","domain","range","zoom_min","zoom_mid","clamp","scale2","zoom_max","prev_choice","new_choice","ranges","start","sprite_size","end","push","embedding_chunks","embedding_stack","slice","c","echunk","points","scene","children","numVertices","length","geometry","attributes","array","target","Float32Array","index","l","tween","Tween","to","easing","Easing","Linear","None","onUpdate","BufferAttribute","needsUpdate","computeBoundingSphere","color_array","color_array_stack","label_chunks","label_stack","lchunk","color_o","color","colors","rvFOV","Math","degToRad","fov","scale_height","camera_z_position","tan","half_fov_height","fov_height","d3_transform","event","k","set","zoomScaler","input","new_size","point_group","material","uniforms","size","value","embeddings","vFOV","xs","e","min_x","min","max_x","max","ys","min_y","max_y","data_width","data_height","data_aspect","max_x_from_center","m","abs","max_y_from_center","max_center","camera_z_start","far","zoom","scaleExtent","on","zoomHandler","call","initial_scale","initial_transform","labels","loader","TextureLoader","textures","t","load","flipY","magFilter","NearestFilter","Group","vertices","v","embedding","vert","Vector3","BufferGeometry","positions","offsets","addAttribute","texture_subsize_x","sprite_side_x","texture_subsize_y","sprite_side_y","sprite_image_width","sprite_actual_size","floor","sprite_image_height","point_size","texture","repeat","Vector2","vertex_shader","fragment_shader","colored_images","ShaderMaterial","vertexShader","fragmentShader","point_cloud","Points","userData","sprite_index","add","hover_container","hoover_size","transparent","point","frustumCulled","visible","digit_index","full_index","algorithm_choice","copyVector3sArray","offset","highlight_container","highlights","remove","mouse_position","sidebar_ctx","sidebar_image_size_width","sidebar_image_size_height","mouseToThree","mouseX","mouseY","sortIntersectsByDistanceToRay","intersects","sortBy","mouse_vector","raycaster","setFromCamera","params","threshold","intersectObjects","sorted_intersects","intersect","object","setHoverIndex","highlightPoint","fillRect","drawImage","domElement","Raycaster","mouse","node","checkIntersects","Scene","near","PerspectiveCamera","WebGLRenderer","setClearColor","appendChild","addBlankHighlightPoints","handleMouse","requestAnimationFrame","update","render","prevProps","label_choice","removeChild","overflow"],"mappings":"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","sourcesContent":["import React, { Component } from 'react'\r\nimport * as THREE from 'three'\r\nimport * as _ from 'lodash'\r\nimport * as d3 from 'd3'\r\nimport * as TWEEN from '@tweenjs/tween.js'\r\n\r\nlet tile_string = 'tile_image_'\r\n\r\nclass Projection extends Component {\r\n  constructor(props) {\r\n    super(props)\r\n    this.state = {}\r\n    this.init = this.init.bind(this)\r\n    this.addPoints = this.addPoints.bind(this)\r\n    this.handleResize = this.handleResize.bind(this)\r\n    this.setUpCamera = this.setUpCamera.bind(this)\r\n    this.animate = this.animate.bind(this)\r\n    this.getScaleFromZ = this.getScaleFromZ.bind(this)\r\n    this.getZFromScale = this.getZFromScale.bind(this)\r\n    this.changeEmbeddings = this.changeEmbeddings.bind(this)\r\n    this.changeLabels = this.changeLabels.bind(this)\r\n    this.tile_locations = [...Array(this.props.sprite_number)].map(\r\n      (n, i) => `${process.env.PUBLIC_URL}/${tile_string}${i}.png`\r\n    )\r\n    this._images = this.tile_locations.map(src => {\r\n      let img = document.createElement('img')\r\n      img.src = src\r\n      return img\r\n    })\r\n    this.scale1 = d3\r\n      .scaleLinear()\r\n      .domain([20, 3])\r\n      .range([this.props.zoom_min, this.props.zoom_mid])\r\n      .clamp(true)\r\n    this.scale2 = d3\r\n      .scaleLinear()\r\n      .domain([3, 0])\r\n      .range([this.props.zoom_mid, this.props.zoom_max])\r\n  }\r\n\r\n  changeEmbeddings(prev_choice, new_choice) {\r\n    // assumes mnist embeddings has been updated\r\n    let ranges = []\r\n    for (let i = 0; i < this.props.sprite_number; i++) {\r\n      let start = i * this.props.sprite_size\r\n      let end = (i + 1) * this.props.sprite_size\r\n      if (i === this.props.sprite_number - 1) end = this.props.sprite_number * this.props.sprite_size\r\n      ranges.push([start, end])\r\n    }\r\n\r\n    let embedding_chunks = ranges.map(range =>\r\n      this.props.embedding_stack[new_choice].slice(\r\n        range[0],\r\n        range[1]\r\n      )\r\n    )\r\n\r\n    for (let c = 0; c < this.props.sprite_number; c++) {\r\n      let echunk = embedding_chunks[c]\r\n\r\n      let points = this.scene.children[0].children[c]\r\n      let numVertices = echunk.length\r\n      let position = points.geometry.attributes.position.array\r\n      let target = new Float32Array(numVertices * 3)\r\n      for (let i = 0, index = 0, l = numVertices; i < l; i++, index += 3) {\r\n        let x = echunk[i][0]\r\n        let y = echunk[i][1]\r\n        let z = 0\r\n        target[index] = x\r\n        target[index + 1] = y\r\n        target[index + 2] = z\r\n      }\r\n\r\n\r\n      let tween = new TWEEN.Tween(position)\r\n        .to(target, 1000)\r\n        .easing(TWEEN.Easing.Linear.None)\r\n      tween.onUpdate(function() {\r\n        points.geometry.attributes.position = new THREE.BufferAttribute(\r\n          position,\r\n          3\r\n        )\r\n        points.geometry.attributes.position.needsUpdate = true // required after the first render\r\n        points.geometry.computeBoundingSphere()\r\n      })\r\n      tween.start()\r\n    }\r\n\r\n  }\r\n\r\n  changeLabels(new_choice) {\r\n    // assumes mnist embeddings has been updated\r\n    let color_array = this.props.color_array_stack[new_choice]\r\n    let ranges = []\r\n    for (let i = 0; i < this.props.sprite_number; i++) {\r\n      let start = i * this.props.sprite_size\r\n      let end = (i + 1) * this.props.sprite_size\r\n      if (i === this.props.sprite_number - 1) end = this.props.sprite_number * this.props.sprite_size\r\n      ranges.push([start, end])\r\n    }\r\n\r\n    let label_chunks = ranges.map(range =>\r\n      this.props.label_stack[new_choice].slice(\r\n        range[0],\r\n        range[1]\r\n      )\r\n    )\r\n\r\n    for (let c = 0; c < this.props.sprite_number; c++) {\r\n      let points = this.scene.children[0].children[c]\r\n      let lchunk = label_chunks[c]\r\n      let numVertices = lchunk.length\r\n      let color_o = points.geometry.attributes.color.array\r\n      let colors = new Float32Array(numVertices * 3)\r\n\r\n      for (let i = 0, index = 0, l = numVertices; i < l; i++, index += 3) {\r\n        let color = color_array[lchunk[i]]\r\n        colors[index] = color[0] / 255\r\n        colors[index + 1] = color[1] / 255\r\n        colors[index + 2] = color[2] / 255\r\n      }\r\n\r\n      let tween = new TWEEN.Tween(color_o)\r\n        .to(colors, 1000)\r\n        .easing(TWEEN.Easing.Linear.None)\r\n      tween.onUpdate(function() {\r\n        points.geometry.attributes.color = new THREE.BufferAttribute(color_o, 3)\r\n        points.geometry.attributes.color.needsUpdate = true // required after the first render\r\n        points.geometry.computeBoundingSphere()\r\n      })\r\n      tween.start()\r\n    }\r\n  }\r\n\r\n  getZFromScale(scale) {\r\n    let rvFOV = THREE.Math.degToRad(this.camera.fov)\r\n    let scale_height = this.props.height / scale\r\n    let camera_z_position = scale_height / (2 * Math.tan(rvFOV / 2))\r\n    return camera_z_position\r\n  }\r\n\r\n  getScaleFromZ(camera_z_position) {\r\n    let rvFOV = THREE.Math.degToRad(this.camera.fov)\r\n    let half_fov_height = Math.tan(rvFOV / 2) * camera_z_position\r\n    let fov_height = half_fov_height * 2\r\n    let scale = this.props.height / fov_height\r\n    return scale\r\n  }\r\n\r\n  handleResize = (width, height) => {\r\n    this.camera.aspect = width / height\r\n    this.camera.updateProjectionMatrix()\r\n    this.renderer.setSize(width, height)\r\n    let current_scale = this.getScaleFromZ(this.camera.position.z)\r\n    let d3_x = -(this.camera.position.x * current_scale) + this.props.width / 2\r\n    let d3_y = this.camera.position.y * current_scale + this.props.height / 2\r\n    var resize_transform = d3.zoomIdentity\r\n      .translate(d3_x, d3_y)\r\n      .scale(current_scale)\r\n    let view = d3.select(this.mount)\r\n    this.d3_zoom.transform(view, resize_transform)\r\n  }\r\n\r\n  zoomHandler() {\r\n    let d3_transform = d3.event.transform\r\n\r\n    let scale = d3_transform.k\r\n    let x = -(d3_transform.x - this.props.width / 2) / scale\r\n    let y = (d3_transform.y - this.props.height / 2) / scale\r\n    let z = this.getZFromScale(scale)\r\n\r\n    this.camera.position.set(x, y, z)\r\n\r\n    // point size scales at end of zoom\r\n\r\n    let zoomScaler = input => {\r\n      if (input >= 3) {\r\n        return this.scale1(input)\r\n      } else  {\r\n        return this.scale2(input)\r\n      }\r\n    }\r\n    let new_size = zoomScaler(z)\r\n    let point_group = this.scene.children[0].children\r\n    for (let c = 0; c < point_group.length; c++) {\r\n      point_group[c].material.uniforms.size.value = new_size\r\n    }\r\n  }\r\n\r\n  setUpCamera() {\r\n    let { width, height, embeddings } = this.props\r\n\r\n    let aspect = this.camera.aspect\r\n    let vFOV = this.camera.fov\r\n    let rvFOV = THREE.Math.degToRad(vFOV)\r\n\r\n    let xs = embeddings.map(e => e[0])\r\n    let min_x = _.min(xs)\r\n    let max_x = _.max(xs)\r\n    let ys = embeddings.map(e => e[1])\r\n    let min_y = _.min(ys)\r\n    let max_y = _.max(ys)\r\n    let data_width = max_x - min_x\r\n    let data_height = max_y - min_y\r\n    let data_aspect = data_width / data_height\r\n\r\n    let max_x_from_center = _.max([min_x, max_x].map(m => Math.abs(m)))\r\n    let max_y_from_center = _.max([min_y, max_y].map(m => Math.abs(m)))\r\n\r\n    let max_center = Math.max(max_x_from_center, max_y_from_center)\r\n\r\n    let camera_z_start\r\n    if (data_aspect > aspect) {\r\n      // console.log(\"width is limiter\");\r\n      // camera_z_start = max_x_from_center / Math.tan(rvFOV / 2) / aspect\r\n    } else {\r\n      // console.log(\"height is limiter\");\r\n      // camera_z_start = max_y_from_center / Math.tan(rvFOV / 2)\r\n    }\r\n\r\n    camera_z_start = max_center / Math.tan(rvFOV / 2)\r\n\r\n    let far = camera_z_start * 1.25\r\n    this.camera.far = far\r\n    this.camera.position.z = camera_z_start * 1.1\r\n\r\n    // set up zoom\r\n    this.d3_zoom = d3\r\n      .zoom()\r\n      .scaleExtent([this.getScaleFromZ(far - 1), this.getScaleFromZ(0.1)])\r\n      .on('zoom', this.zoomHandler.bind(this))\r\n\r\n    let view = d3.select(this.mount)\r\n    this.view = view\r\n    view.call(this.d3_zoom)\r\n    let initial_scale = this.getScaleFromZ(this.camera.position.z)\r\n    var initial_transform = d3.zoomIdentity\r\n      .translate(width / 2, height / 2)\r\n      .scale(initial_scale)\r\n    this.d3_zoom.transform(view, initial_transform)\r\n  }\r\n\r\n  addPoints() {\r\n    let { embeddings, labels, color_array } = this.props\r\n    \r\n\r\n    // split embeddings and labels into chunks to match sprites\r\n    let ranges = []\r\n    for (let i = 0; i < this.props.sprite_number; i++) {\r\n      let start = i * this.props.sprite_size\r\n      let end = (i + 1) * this.props.sprite_size\r\n      if (i === this.props.sprite_number - 1) end = this.props.sprite_number * this.props.sprite_size\r\n      ranges.push([start, end])\r\n    }\r\n    let embedding_chunks = ranges.map(range =>\r\n      embeddings.slice(range[0], range[1])\r\n    )\r\n    let label_chunks = ranges.map(range =>\r\n      labels.slice(range[0], range[1])\r\n    )\r\n\r\n    // load the textures\r\n    let loader = new THREE.TextureLoader()\r\n    this.textures = this.tile_locations.map(l => {\r\n      let t = loader.load(l)\r\n      t.flipY = false\r\n      t.magFilter = THREE.NearestFilter\r\n      // t.minFilter = THREE.LinearMipMapLinearFilter;\r\n      return t\r\n    })\r\n\r\n    let point_group = new THREE.Group()\r\n    for (let c = 0; c < this.props.sprite_number; c++) {\r\n      let echunk = embedding_chunks[c]\r\n      let lchunk = label_chunks[c]\r\n\r\n      let vertices = []\r\n      for (let v = 0; v < echunk.length; v++) {\r\n        let embedding = echunk[v]\r\n        let vert = new THREE.Vector3(embedding[0], embedding[1], 0)\r\n        vertices[v] = vert\r\n      }\r\n\r\n      let geometry = new THREE.BufferGeometry()\r\n\r\n      let numVertices = vertices.length\r\n      let positions = new Float32Array(numVertices * 3)\r\n      let offsets = new Float32Array(numVertices * 2)\r\n      let colors = new Float32Array(numVertices * 3)\r\n      geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3))\r\n      geometry.addAttribute('offset', new THREE.BufferAttribute(offsets, 2))\r\n      geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3))\r\n\r\n      for (let i = 0, index = 0, l = numVertices; i < l; i++, index += 3) {\r\n        let x = echunk[i][0]\r\n        let y = echunk[i][1]\r\n        let z = 0\r\n        positions[index] = x\r\n        positions[index + 1] = y\r\n        positions[index + 2] = z\r\n      }\r\n\r\n      // geometry.attributes.position.copyVector3sArray(vertices)\r\n\r\n      let texture_subsize_x = 1 / this.props.sprite_side_x\r\n      let texture_subsize_y = 1 / this.props.sprite_side_y\r\n\r\n      for (let i = 0, index = 0, l = numVertices; i < l; i++, index += 2) {\r\n        let x = ((i % this.props.sprite_side_x) * this.props.sprite_image_width) / this.props.sprite_actual_size\r\n        let y =\r\n          (Math.floor(i / this.props.sprite_side_y) * this.props.sprite_image_height) / this.props.sprite_actual_size\r\n        offsets[index] = x\r\n        offsets[index + 1] = y\r\n      }\r\n\r\n      \r\n      for (let i = 0, index = 0, l = numVertices; i < l; i++, index += 3) {\r\n        let color = color_array[lchunk[i]]\r\n        colors[index] = color[0] / 255\r\n        colors[index + 1] = color[1] / 255\r\n        colors[index + 2] = color[2] / 255\r\n      }\r\n      let point_size = Math.max(this.props.sprite_image_width,this.props.sprite_image_height)\r\n      // uniforms\r\n      let uniforms = {\r\n        texture: { value: this.textures[c] },\r\n        repeat: { value: new THREE.Vector2(texture_subsize_x, texture_subsize_y) },\r\n        size: { value:  point_size},\r\n        height: {value: this.props.sprite_image_height},\r\n        width: {value: this.props.sprite_image_width},\r\n      }\r\n\r\n      let vertex_shader = `\r\n        attribute vec2 offset;\r\n        varying vec2 vOffset;\r\n        attribute vec3 color;\r\n        varying vec3 vColor;\r\n        uniform float size;\r\n        void main() {\r\n          vOffset = offset;\r\n          vColor = color;\r\n          gl_PointSize = size;\r\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`\r\n      let fragment_shader\r\n      if (this.props.colored_images == 0){\r\n        fragment_shader = `\r\n          uniform sampler2D texture;\r\n          uniform vec2 repeat;\r\n          uniform float height;\r\n          uniform float width;\r\n          varying vec2 vOffset;\r\n          varying vec3 vColor;\r\n          void main() {\r\n            if (width>height){\r\n              float height_rel = height/width;\r\n              float start_rel = (width-height)/(2.0*width);\r\n              float end_rel = start_rel+height_rel;\r\n              if (gl_PointCoord.y>=start_rel && gl_PointCoord.y<=end_rel) {\r\n                float y_new = ((gl_PointCoord.y-start_rel)/height_rel);\r\n                vec2 uv = vec2( gl_PointCoord.x, y_new );\r\n                vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n                if ( tex.r < 0.05 ) discard;\r\n                tex.r = 1.0;\r\n                tex.g = 1.0;\r\n                tex.b = 1.0;\r\n                gl_FragColor = tex * vec4(vColor, 1.0);\r\n              } else {\r\n                discard;\r\n              }\r\n            } else if (width<height) {\r\n              float width_rel = width/height;\r\n              float start_rel = (height-width)/(2.0*height);\r\n              float end_rel = start_rel+width_rel;\r\n              if (gl_PointCoord.x>=start_rel && gl_PointCoord.x<=end_rel) {\r\n                float x_new = ((gl_PointCoord.x-start_rel)/width_rel);\r\n                vec2 uv = vec2( x_new,gl_PointCoord.y );\r\n                vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n                if ( tex.r < 0.05 ) discard;\r\n                tex.r = 1.0;\r\n                tex.g = 1.0;\r\n                tex.b = 1.0;\r\n                gl_FragColor = tex * vec4(vColor, 1.0);\r\n              } else {\r\n                discard;\r\n              }\r\n            } else {\r\n              vec2 uv = vec2( gl_PointCoord.x, gl_PointCoord.y );\r\n              vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n              if ( tex.r < 0.5) discard;\r\n              tex.r = 1.0;\r\n              tex.g = 1.0;\r\n              tex.b = 1.0;\r\n              gl_FragColor = tex * vec4(vColor, 1.0); \r\n            }\r\n          }`\r\n      }else if (this.props.colored_images == -1){\r\n        fragment_shader = `\r\n          uniform sampler2D texture;\r\n          uniform vec2 repeat;\r\n          uniform float height;\r\n          uniform float width;\r\n          varying vec2 vOffset;\r\n          varying vec3 vColor;\r\n          void main() {\r\n            if (width>height){\r\n              float height_rel = height/width;\r\n              float start_rel = (width-height)/(2.0*width);\r\n              float end_rel = start_rel+height_rel;\r\n              if (gl_PointCoord.y>=start_rel && gl_PointCoord.y<=end_rel) {\r\n                float y_new = ((gl_PointCoord.y-start_rel)/height_rel);\r\n                vec2 uv = vec2( gl_PointCoord.x, y_new );\r\n                vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n                if ( tex.r < 0.05 ) discard;\r\n                tex.r = 1.0;\r\n                tex.g = 1.0;\r\n                tex.b = 1.0;\r\n                gl_FragColor = tex * vec4(vColor, 1.0);\r\n              } else {\r\n                discard;\r\n              }\r\n            } else if (width<height) {\r\n              float width_rel = width/height;\r\n              float start_rel = (height-width)/(2.0*height);\r\n              float end_rel = start_rel+width_rel;\r\n              if (gl_PointCoord.x>=start_rel && gl_PointCoord.x<=end_rel) {\r\n                float x_new = ((gl_PointCoord.x-start_rel)/width_rel);\r\n                vec2 uv = vec2( x_new,gl_PointCoord.y );\r\n                vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n                if ( tex.r < 0.05 ) discard;\r\n                tex.r = 1.0;\r\n                tex.g = 1.0;\r\n                tex.b = 1.0;\r\n                gl_FragColor = tex * vec4(vColor, 1.0);\r\n              } else {\r\n                discard;\r\n              }\r\n            } else {\r\n              vec2 uv = vec2( gl_PointCoord.x, gl_PointCoord.y );\r\n              vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n              if ( tex.b < 0.5 && tex.r==0.0) discard;\r\n              if (tex.r>0.0){\r\n                tex.r = tex.r;\r\n                tex.g = 0.0;\r\n                tex.b = 0.0;\r\n                gl_FragColor = tex; \r\n              }\r\n              else{\r\n                tex.r = 1.0;\r\n                tex.g = 1.0;\r\n                tex.b = 1.0;\r\n                gl_FragColor = tex * vec4(vColor, 1.0); \r\n              }\r\n            }\r\n          }`\r\n      }else{\r\n        fragment_shader = `\r\n        uniform sampler2D texture;\r\n        uniform vec2 repeat;\r\n        uniform float height;\r\n        uniform float width;\r\n        varying vec2 vOffset;\r\n        varying vec3 vColor;\r\n        void main() {\r\n          if (width>height){\r\n            float height_rel = height/width;\r\n            float start_rel = (width-height)/(2.0*width);\r\n            float end_rel = start_rel+height_rel;\r\n            if (gl_PointCoord.y>=start_rel && gl_PointCoord.y<=end_rel) {\r\n              float y_new = ((gl_PointCoord.y-start_rel)/height_rel);\r\n              vec2 uv = vec2( gl_PointCoord.x, y_new );\r\n              vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n              gl_FragColor = tex;\r\n            } else {\r\n              discard;\r\n            }\r\n          } else if (width<height) {\r\n            float width_rel = width/height;\r\n            float start_rel = (height-width)/(2.0*height);\r\n            float end_rel = start_rel+width_rel;\r\n            if (gl_PointCoord.x>=start_rel && gl_PointCoord.x<=end_rel) {\r\n              float x_new = ((gl_PointCoord.x-start_rel)/width_rel);\r\n              vec2 uv = vec2( x_new, gl_PointCoord.y );\r\n              vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n              gl_FragColor = tex;\r\n            } else {\r\n              discard;\r\n            }\r\n          } else {\r\n            vec2 uv = vec2( gl_PointCoord.x, gl_PointCoord.y );\r\n            vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n            gl_FragColor = tex;\r\n          }\r\n        }`\r\n      }\r\n\r\n      // material\r\n      let material = new THREE.ShaderMaterial({\r\n        uniforms: uniforms,\r\n        vertexShader: vertex_shader,\r\n        fragmentShader: fragment_shader,\r\n      })\r\n\r\n      // point cloud\r\n      let point_cloud = new THREE.Points(geometry, material)\r\n      point_cloud.userData = { sprite_index: c }\r\n\r\n      point_group.add(point_cloud)\r\n    }\r\n\r\n    this.scene.add(point_group)\r\n  }\r\n\r\n  addBlankHighlightPoints() {\r\n    let hover_container = new THREE.Group()\r\n    this.scene.add(hover_container)\r\n\r\n    let vert = new THREE.Vector3(0, 0, 0)\r\n    let vertices = [vert]\r\n    let geometry = new THREE.BufferGeometry()\r\n    let numVertices = vertices.length\r\n    var positions = new Float32Array(numVertices * 3) // 3 coordinates per point\r\n    var offsets = new Float32Array(numVertices * 2) // 2 coordinates per point\r\n    geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3))\r\n    geometry.addAttribute('offset', new THREE.BufferAttribute(offsets, 2))\r\n\r\n    // all the attributes will be filled on hover\r\n    let texture_subsize_x = 1 / this.props.sprite_side_x\r\n    let texture_subsize_y = 1 / this.props.sprite_side_y\r\n\r\n    let point_size = this.props.hoover_size//Math.max(this.props.sprite_image_width,this.props.sprite_image_height)\r\n    // uniforms\r\n    let uniforms = {\r\n      texture: { value: this.textures[0] },\r\n      repeat: { value: new THREE.Vector2(texture_subsize_x, texture_subsize_y) },\r\n      size: { value:  point_size},\r\n      height: {value: this.props.sprite_image_height},\r\n      width: {value: this.props.sprite_image_width},\r\n    }\r\n\r\n    let vertex_shader = `\r\n        attribute vec2 offset;\r\n        varying vec2 vOffset;\r\n        uniform float size;\r\n        void main() {\r\n          vOffset = offset;\r\n          gl_PointSize = size;\r\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`\r\n\r\n      let fragment_shader\r\n      if (this.props.colored_images == 0){\r\n        fragment_shader = `\r\n          uniform sampler2D texture;\r\n          uniform vec2 repeat;\r\n          uniform float height;\r\n          uniform float width;\r\n          varying vec2 vOffset;\r\n          varying vec3 vColor;\r\n          void main() {\r\n            if (width>height){\r\n              float height_rel = height/width;\r\n              float start_rel = (width-height)/(2.0*width);\r\n              float end_rel = start_rel+height_rel;\r\n              if (gl_PointCoord.y>=start_rel && gl_PointCoord.y<=end_rel) {\r\n                float y_new = ((gl_PointCoord.y-start_rel)/height_rel);\r\n                vec2 uv = vec2( gl_PointCoord.x, y_new );\r\n                vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n                tex.a = tex.r;\r\n                tex.r = 1.0;\r\n                tex.g = 1.0;\r\n                tex.b = 1.0;\r\n                gl_FragColor = tex;\r\n              } else {\r\n                discard;\r\n              }\r\n            } else if (width<height) {\r\n              float width_rel = width/height;\r\n              float start_rel = (height-width)/(2.0*height);\r\n              float end_rel = start_rel+width_rel;\r\n              if (gl_PointCoord.x>=start_rel && gl_PointCoord.x<=end_rel) {\r\n                float x_new = ((gl_PointCoord.x-start_rel)/width_rel);\r\n                vec2 uv = vec2( x_new,gl_PointCoord.y );\r\n                vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n                tex.a = tex.r;\r\n                tex.r = 1.0;\r\n                tex.g = 1.0;\r\n                tex.b = 1.0;\r\n                gl_FragColor = tex; \r\n              } else {\r\n                discard;\r\n              }\r\n            } else {\r\n              vec2 uv = vec2( gl_PointCoord.x, gl_PointCoord.y );\r\n              vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n              tex.a = tex.r;\r\n              tex.r = 1.0;\r\n              tex.g = 1.0;\r\n              tex.b = 1.0;\r\n              gl_FragColor = tex; \r\n            }\r\n          }`\r\n      }else{\r\n        fragment_shader = `\r\n        uniform sampler2D texture;\r\n        uniform vec2 repeat;\r\n        uniform float height;\r\n        uniform float width;\r\n        varying vec2 vOffset;\r\n        varying vec3 vColor;\r\n        void main() {\r\n          if (width>height){\r\n            float height_rel = height/width;\r\n            float start_rel = (width-height)/(2.0*width);\r\n            float end_rel = start_rel+height_rel;\r\n            if (gl_PointCoord.y>=start_rel && gl_PointCoord.y<=end_rel) {\r\n              float y_new = ((gl_PointCoord.y-start_rel)/height_rel);\r\n              vec2 uv = vec2( gl_PointCoord.x, y_new );\r\n              vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n              gl_FragColor = tex;\r\n            } else {\r\n              discard;\r\n            }\r\n          } else if (width<height) {\r\n            float width_rel = width/height;\r\n            float start_rel = (height-width)/(2.0*height);\r\n            float end_rel = start_rel+width_rel;\r\n            if (gl_PointCoord.x>=start_rel && gl_PointCoord.x<=end_rel) {\r\n              float x_new = ((gl_PointCoord.x-start_rel)/width_rel);\r\n              vec2 uv = vec2( x_new, gl_PointCoord.y );\r\n              vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n              gl_FragColor = tex;\r\n            } else {\r\n              discard;\r\n            }\r\n          } else {\r\n            vec2 uv = vec2( gl_PointCoord.x, gl_PointCoord.y );\r\n            vec4 tex = texture2D( texture, uv * repeat + vOffset );\r\n            gl_FragColor = tex;\r\n          }\r\n        }`\r\n      }\r\n\r\n    // material\r\n    var material = new THREE.ShaderMaterial({\r\n      uniforms: uniforms,\r\n      vertexShader: vertex_shader,\r\n      fragmentShader: fragment_shader,\r\n      transparent: true,\r\n    })\r\n\r\n    let point = new THREE.Points(geometry, material)\r\n    point.frustumCulled = false\r\n\r\n    this.scene.children[1].visible = false\r\n    this.scene.children[1].add(point)\r\n  }\r\n\r\n\r\n  highlightPoint(sprite_index, digit_index, full_index) {\r\n    let { algorithm_choice} = this.props\r\n\r\n    let point = this.scene.children[1].children[0]\r\n\r\n    let embedding = this.props.embedding_stack.slice()[algorithm_choice][full_index]\r\n    //[full_index]\r\n\r\n    let vert = new THREE.Vector3(embedding[0], embedding[1], 0)\r\n    let vertices = [vert]\r\n\r\n    var offsets = new Float32Array(2) // 2 coordinates per point\r\n\r\n    let x = ((digit_index % this.props.sprite_side_x) * this.props.sprite_image_width) / this.props.sprite_actual_size\r\n    let y = (Math.floor(digit_index / this.props.sprite_side_y) * this.props.sprite_image_height) / this.props.sprite_actual_size\r\n    offsets[0] = x\r\n    offsets[1] = y\r\n\r\n    point.geometry.attributes.position.copyVector3sArray(vertices)\r\n    point.geometry.attributes.position.needsUpdate = true // required after the first render\r\n    point.geometry.attributes.offset.array = offsets\r\n    point.geometry.attributes.offset.needsUpdate = true // required after the first render\r\n\r\n    // need to set attributes on geometry and uniforms on material\r\n    point.material.uniforms.texture.value = this.textures[sprite_index]\r\n  }\r\n\r\n  removeHighlights() {\r\n    let highlight_container = this.scene.children[1]\r\n    let highlights = highlight_container.children\r\n    highlight_container.remove(...highlights)\r\n  }\r\n\r\n  checkIntersects(mouse_position) {\r\n    let { width, height, sidebar_ctx, sidebar_image_size_width, sidebar_image_size_height } = this.props\r\n\r\n    function mouseToThree([mouseX, mouseY]) {\r\n      return new THREE.Vector3(\r\n        (mouseX / width) * 2 - 1,\r\n        -(mouseY / height) * 2 + 1,\r\n        1\r\n      )\r\n    }\r\n\r\n    function sortIntersectsByDistanceToRay(intersects) {\r\n      return _.sortBy(intersects, 'distanceToRay')\r\n    }\r\n\r\n    let mouse_vector = mouseToThree(mouse_position)\r\n    this.raycaster.setFromCamera(mouse_vector, this.camera)\r\n    this.raycaster.params.Points.threshold = 0.5\r\n    let intersects = this.raycaster.intersectObjects(\r\n      this.scene.children[0].children\r\n    )\r\n    if (intersects[0]) {\r\n      let sorted_intersects = sortIntersectsByDistanceToRay(intersects)\r\n      let intersect = sorted_intersects[0]\r\n      let sprite_index = intersect.object.userData.sprite_index\r\n      let digit_index = intersect.index\r\n      let full_index = sprite_index * this.props.sprite_size + digit_index\r\n      this.props.setHoverIndex(full_index)\r\n      this.highlightPoint(sprite_index, digit_index, full_index)\r\n      this.scene.children[1].visible = true\r\n\r\n      sidebar_ctx.fillRect(0, 0, sidebar_image_size_width, sidebar_image_size_height)\r\n      sidebar_ctx.drawImage(\r\n        this._images[sprite_index],\r\n        // source rectangle\r\n        (digit_index % this.props.sprite_side_x) * this.props.sprite_image_width,\r\n        Math.floor(digit_index / this.props.sprite_side_y) * this.props.sprite_image_height,\r\n        this.props.sprite_image_width,\r\n        this.props.sprite_image_height,\r\n        // destination rectangle\r\n        0,\r\n        0,\r\n        sidebar_image_size_width,\r\n        sidebar_image_size_height\r\n      )\r\n    } else {\r\n      this.props.setHoverIndex(null)\r\n      this.scene.children[1].visible = false\r\n      sidebar_ctx.fillRect(0, 0, sidebar_image_size_width, sidebar_image_size_height)\r\n    }\r\n  }\r\n\r\n  handleMouse() {\r\n    let view = d3.select(this.renderer.domElement)\r\n\r\n    this.raycaster = new THREE.Raycaster()\r\n    view.on('mousemove', () => {\r\n      let [mouseX, mouseY] = d3.mouse(view.node())\r\n      let mouse_position = [mouseX, mouseY]\r\n      \r\n\r\n      this.checkIntersects(mouse_position)\r\n    })\r\n  }\r\n\r\n  init() {\r\n    let { width, height,sidebar_ctx } = this.props\r\n\r\n    this.scene = new THREE.Scene()\r\n\r\n    let vFOV = 75\r\n    let aspect = width / height\r\n    let near = 0.01\r\n    let far = 1000\r\n\r\n    this.camera = new THREE.PerspectiveCamera(vFOV, aspect, near, far)\r\n\r\n    this.renderer = new THREE.WebGLRenderer()\r\n    this.renderer.setClearColor(0x111111, 1)\r\n    this.renderer.setSize(width, height)\r\n    this.mount.appendChild(this.renderer.domElement)\r\n    \r\n\r\n    this.addPoints()\r\n\r\n    this.addBlankHighlightPoints()\r\n\r\n    this.setUpCamera()\r\n\r\n    this.animate()\r\n    \r\n    this.handleMouse()\r\n  }\r\n\r\n  animate() {\r\n    requestAnimationFrame(this.animate)\r\n    TWEEN.update()\r\n    this.renderer.render(this.scene, this.camera)\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.init()\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    let { width, height } = this.props\r\n    if (width !== prevProps.width || height !== prevProps.height) {\r\n      this.handleResize(width, height)\r\n    }\r\n    if (prevProps.algorithm_choice !== this.props.algorithm_choice) {\r\n      this.changeEmbeddings(\r\n        prevProps.algorithm_choice,\r\n        this.props.algorithm_choice\r\n      )\r\n    }\r\n    if (prevProps.label_choice !== this.props.label_choice) {\r\n      this.changeLabels(\r\n        this.props.label_choice\r\n      )\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.mount.removeChild(this.renderer.domElement)\r\n  }\r\n\r\n  render() {\r\n    let { width, height } = this.props\r\n    \r\n    return (\r\n      <div\r\n        style={{ width: width, height: height, overflow: 'hidden' }}\r\n        ref={mount => {\r\n          this.mount = mount\r\n        }}\r\n      />\r\n    )\r\n  }\r\n}\r\n\r\nexport default Projection\r\n"]},"metadata":{},"sourceType":"module"}